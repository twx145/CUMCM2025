好的，完全理解你的要求。为问题二设计一个既快速又精确的求解方案，避免暴力搜索，这是一个非常经典且正确的建模思路。你提出的“逆向反推”和“高精度搜索”两步走的策略，正是解决此类优化问题的有效方法。

下面，我将为你提供一套完整的三步法建模方案和对应的Python代码实现。

---

### **第二问建模方案：三步优化法**

这个问题的决策变量是：无人机飞行速度 `v`（70-140 m/s），飞行方向 `θ`（水平角度），烟幕弹投放时间 `t_drop`，以及投放到起爆的延迟时间 `t_delay`。目标是最大化对真目标中心点的有效遮蔽时长。

直接对这四个变量进行暴力搜索，组合数量巨大，不可行。因此，我们采用如下三步法：

**第一步：全局粗搜索——基于逆向可行性分析的最优拦截窗口定位**

核心思想不是去试无人机的参数，而是反过来，先确定导弹轨迹上哪些“时空点”是最理想的烟幕拦截点，然后检验无人机是否有能力在那个时间将烟幕弹送到那个位置。

1.  **离散化导弹轨迹：** 将导弹M1从初始位置到命中假目标的全程飞行时间 `T_M1` 离散化成一系列时间点 `t_i`（例如，每隔0.5秒取一个点）。
2.  **确定理想起爆点：** 在每个时间点 `t_i`，导弹位置为 `P_M(t_i)`。为了最大化遮蔽效率，烟幕云的球心 `P_S(t_i)` 应该正好位于导弹 `P_M(t_i)` 与真目标中心 `P_T` 的连线上。我们可以选择一个具体位置，例如这条连线的中点，或者距离导弹较近的点（这样可以用更小的烟幕覆盖更大的视角）。
3.  **逆向可行性检验：**
    *   对于每一个理想的起爆组合 `(P_S(t_i), t_i)`，我们反向推算无人机需要满足的条件。
    *   **反推起爆前运动：** 烟幕云在 `t_i` 时刻到达 `P_S(t_i)`，是匀速下沉的结果。我们可以倒推出它在起爆瞬间 `t_explode` 的位置 `P_explode`。
    *   **反推烟幕弹弹道：** 从 `P_explode` 和 `t_explode`，我们可以反向计算出烟幕弹在空中飞行的轨迹（抛物线），从而确定它必须在哪个时间 `t_drop` 从哪个位置 `P_drop` 被投放。
    *   **检验无人机能力：** 现在我们有了必须的投放点 `P_drop` 和投放时间 `t_drop`。我们计算从无人机初始位置 `P_FY1(0)` 到达 `P_drop` 所需的平均速度。如果这个速度在 ** m/s** 的区间内，则该方案可行。
4.  **评估与筛选：** 对所有可行的方案，我们用**简化模型（真目标中心点）**快速计算其遮蔽时长。在所有这些方案中，找到那个遮蔽时间最长的，将其对应的无人机策略（速度、方向、投放时间、延迟时间）作为第二步的初始最优解。

**第二步：局部精搜索——坐标上升法**

第一步已经帮我们找到了一个非常好的“山峰”的大致位置。现在我们需要用一个高效的局部搜索算法来精确地“爬到山顶”。坐标上升法是一个简单且高效的选择。

1.  **设定初始解：** 使用第一步找到的最佳策略 `(v_0, θ_0, t_drop_0, t_delay_0)` 作为起点。
2.  **迭代优化：** 循环迭代，每一轮依次对每个决策变量进行一维搜索，以期提升目标函数（遮蔽时长）。
    *   **优化速度 `v`：** 固定其他三个变量，在一维区间 内搜索最佳的 `v`。
    *   **优化方向 `θ`：** 固定其他三个变量，在 [0, 360) 度区间内搜索最佳的 `θ`。
    *   **优化投放时间 `t_drop`：** 固定其他三个变量，在一个合理的范围内搜索最佳的 `t_drop`。
    *   **优化延迟 `t_delay`：** 固定其他三个变量，在一个合理的范围内搜索最佳的 `t_delay`。
3.  **收敛判断：** 当一整轮（四个变量都优化了一遍）迭代后，遮蔽时长的提升非常小（例如小于0.01秒），则认为算法已收敛，找到了局部最优解。此过程同样使用**简化模型**进行计算，以保证速度。

**第三步：最终精度验证**

将第二步找到的“最优”策略参数，代入我们之前建立的**高精度计算模型（在真目标表面随机抽取1000个点）**，进行一次最终的、精确的遮蔽时长计算。这个结果就是我们最终要报告的答案。

---

### **Python 代码实现**

下面的代码将严格按照上述三步法来解决问题。

```python
import numpy as np
import time

# --- 0. 基础设置与物理常量 ---
GRAVITY = 9.8
SMOKE_DURATION = 20.0
SMOKE_RADIUS = 10.0

# 初始位置
uav_initial_pos = np.array([17800, 0, 1800], dtype=float)
missile_initial_pos = np.array([20000, 0, 2000], dtype=float)
false_target_pos = np.array([0, 0, 0], dtype=float)
true_target_base_center = np.array([0, 200, 0], dtype=float)
true_target_height = 10
# 简化模型的目标点 (步骤1和2使用)
simple_target_point = true_target_base_center + np.array([0, 0, true_target_height / 2])

# 导弹轨迹计算
missile_velocity_vector = (false_target_pos - missile_initial_pos) / np.linalg.norm(false_target_pos - missile_initial_pos) * 300.0
missile_total_time = np.linalg.norm(false_target_pos - missile_initial_pos) / 300.0

# --- 辅助函数 ---
def is_line_segment_intersecting_sphere(p1, p2, sphere_center, sphere_radius):
    if np.any(np.isnan(sphere_center)): return False
    line_vec, point_vec = p2 - p1, sphere_center - p1
    line_len_sq = np.dot(line_vec, line_vec)
    if line_len_sq == 0.0: return np.linalg.norm(point_vec) <= sphere_radius
    t = np.dot(point_vec, line_vec) / line_len_sq
    closest_point = p1 + np.clip(t, 0, 1) * line_vec
    return np.linalg.norm(sphere_center - closest_point) <= sphere_radius

def calculate_simple_occlusion_time(uav_vel, uav_dir, t_drop, t_delay):
    """(用于步骤1和2) 使用单个目标点快速计算遮蔽时间"""
    uav_velocity = np.array([np.cos(uav_dir) * uav_vel, np.sin(uav_dir) * uav_vel, 0])
    
    t_explode = t_drop + t_delay
    
    p_drop = uav_initial_pos + uav_velocity * t_drop
    v_drop = uav_velocity
    p_explode = p_drop + v_drop * t_delay + np.array([0, 0, -0.5 * GRAVITY * t_delay**2])

    occluded_time = 0
    time_step = 0.1
    for t in np.arange(t_explode, t_explode + SMOKE_DURATION, time_step):
        missile_pos = missile_initial_pos + missile_velocity_vector * t
        smoke_pos = p_explode + np.array([0, 0, -3.0 * (t - t_explode)])
        if is_line_segment_intersecting_sphere(missile_pos, simple_target_point, smoke_pos, SMOKE_RADIUS):
            occluded_time += time_step
    return occluded_time

# --- 步骤 1: 全局粗搜索 ---
def step1_find_optimal_window():
    print("--- [步骤 1] 开始：全局粗搜索以寻找最优拦截窗口 ---")
    best_params = {}
    max_occlusion_time = -1
    
    # 离散化搜索空间
    # 理想的起爆时间 (导弹飞行时间的中间段更有可能)
    search_explode_times = np.linspace(missile_total_time * 0.4, missile_total_time * 0.9, 20)
    # 烟幕弹飞行时间
    search_delays = np.linspace(2.0, 8.0, 15)
    
    for t_explode in search_explode_times:
        for t_delay in search_delays:
            if t_explode <= t_delay: continue
            
            # 1. 确定理想起爆点 (这里选择LOS的中点)
            missile_pos_at_explode = missile_initial_pos + missile_velocity_vector * t_explode
            los_vector = simple_target_point - missile_pos_at_explode
            ideal_explode_pos = missile_pos_at_explode + 0.5 * los_vector

            # 2. 反推无人机需求
            t_drop = t_explode - t_delay
            
            # 反推抛物线运动，找到投放点和投放速度的组合关系
            # P_explode = P_drop + V_drop*t_delay + 0.5*g*t_delay^2
            # P_drop = P_uav_start + V_uav*t_drop, and V_drop = V_uav
            # => P_explode = P_uav_start + V_uav*t_drop + V_uav*t_delay + ...
            # => P_explode - P_uav_start - 0.5*g*... = V_uav * (t_drop + t_delay)
            
            required_uav_velocity_3d = (ideal_explode_pos - uav_initial_pos - np.array([0, 0, -0.5 * GRAVITY * t_delay**2])) / t_explode
            
            # 无人机是等高飞行的
            if required_uav_velocity_3d[2] != 0:
                # 理论上要求无人机有垂直速度，这可以通过调整理想起爆点的高度来修正
                # 简单处理：将垂直分量归零，这等效于调整了理想起爆点的高度
                required_uav_velocity_3d[2] = 0

            # 3. 检验无人机能力
            required_speed = np.linalg.norm(required_uav_velocity_3d)
            if 70 <= required_speed <= 140:
                # 方案可行，评估其效果
                uav_dir_rad = np.arctan2(required_uav_velocity_3d[1], required_uav_velocity_3d[0])
                current_occlusion_time = calculate_simple_occlusion_time(required_speed, uav_dir_rad, t_drop, t_delay)
                
                if current_occlusion_time > max_occlusion_time:
                    max_occlusion_time = current_occlusion_time
                    best_params = {
                        'v': required_speed,
                        'theta_rad': uav_dir_rad,
                        't_drop': t_drop,
                        't_delay': t_delay,
                        'occlusion_time': max_occlusion_time
                    }
    
    print(f"步骤1完成。找到的最佳初始解：")
    print(f"  速度: {best_params['v']:.2f} m/s, 方向: {np.degrees(best_params['theta_rad']):.2f} 度")
    print(f"  投放时间: {best_params['t_drop']:.2f} s, 延迟引爆: {best_params['t_delay']:.2f} s")
    print(f"  预估遮蔽时长 (简化模型): {best_params['occlusion_time']:.2f} s")
    return best_params

# --- 步骤 2: 局部精搜索 ---
def step2_local_optimization(initial_params):
    print("\n--- [步骤 2] 开始：使用坐标上升法进行局部精细搜索 ---")
    
    params = initial_params.copy()
    
    for i in range(5): # 迭代5轮
        print(f"迭代轮次 {i+1}/5...")
        last_occlusion_time = params['occlusion_time']
        
        # 优化速度 v
        for v_test in np.linspace(max(70, params['v']-5), min(140, params['v']+5), 11):
            t = calculate_simple_occlusion_time(v_test, params['theta_rad'], params['t_drop'], params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['v'] = t, v_test
        
        # 优化方向 theta
        for theta_test in np.linspace(params['theta_rad']-np.radians(10), params['theta_rad']+np.radians(10), 11):
            t = calculate_simple_occlusion_time(params['v'], theta_test, params['t_drop'], params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['theta_rad'] = t, theta_test
            
        # 优化投放时间 t_drop
        for t_drop_test in np.linspace(max(0.1, params['t_drop']-1), params['t_drop']+1, 11):
            t = calculate_simple_occlusion_time(params['v'], params['theta_rad'], t_drop_test, params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['t_drop'] = t, t_drop_test

        # 优化延迟时间 t_delay
        for t_delay_test in np.linspace(max(0.1, params['t_delay']-1), params['t_delay']+1, 11):
            t = calculate_simple_occlusion_time(params['v'], params['theta_rad'], params['t_drop'], t_delay_test)
            if t > params['occlusion_time']: params['occlusion_time'], params['t_delay'] = t, t_delay_test

        if params['occlusion_time'] - last_occlusion_time < 0.01:
            print("遮蔽时长提升小于0.01s，算法收敛。")
            break
            
    print(f"步骤2完成。优化后的解：")
    print(f"  速度: {params['v']:.4f} m/s, 方向: {np.degrees(params['theta_rad']):.4f} 度")
    print(f"  投放时间: {params['t_drop']:.4f} s, 延迟引爆: {params['t_delay']:.4f} s")
    print(f"  预估遮蔽时长 (简化模型): {params['occlusion_time']:.4f} s")
    return params

# --- 步骤 3: 最终精度验证 ---
def step3_final_validation(final_params, n_points=1000):
    print(f"\n--- [步骤 3] 开始：使用{n_points}个目标点进行最终精度验证 ---")
    
    # 生成目标表面采样点
    points = []
    for _ in range(int(n_points * 0.6)):
        theta, z = 2 * np.pi * np.random.rand(), true_target_height * np.random.rand()
        points.append([true_target_base_center[0] + 7 * np.cos(theta), true_target_base_center[1] + 7 * np.sin(theta), z])
    for _ in range(int(n_points * 0.4)):
        r, theta = 7 * np.sqrt(np.random.rand()), 2 * np.pi * np.random.rand()
        z = 0 if np.random.rand() < 0.5 else true_target_height
        points.append([true_target_base_center[0] + r * np.cos(theta), true_target_base_center[1] + r * np.sin(theta), z])
    target_points = np.array(points)
    
    # 使用最优参数计算轨迹
    v, theta, t_drop, t_delay = final_params['v'], final_params['theta_rad'], final_params['t_drop'], final_params['t_delay']
    uav_velocity = np.array([np.cos(theta) * v, np.sin(theta) * v, 0])
    t_explode = t_drop + t_delay
    p_drop = uav_initial_pos + uav_velocity * t_drop
    v_drop = uav_velocity
    p_explode = p_drop + v_drop * t_delay + np.array([0, 0, -0.5 * GRAVITY * t_delay**2])

    # 高精度计算
    total_occluded_time = 0
    time_step = 0.01
    for t in np.arange(t_explode, t_explode + SMOKE_DURATION, time_step):
        missile_pos = missile_initial_pos + missile_velocity_vector * t
        smoke_pos = p_explode + np.array([0, 0, -3.0 * (t - t_explode)])
        
        is_occluded_this_step = False
        for target_point in target_points:
            if is_line_segment_intersecting_sphere(missile_pos, target_point, smoke_pos, SMOKE_RADIUS):
                is_occluded_this_step = True
                break
        
        if is_occluded_this_step:
            total_occluded_time += time_step
            
    print("\n" + "="*50)
    print("  第二问最优策略及最终结果")
    print("="*50)
    print("  最优策略参数:")
    print(f"    无人机飞行速度: {v:.4f} m/s")
    print(f"    无人机飞行方向: {np.degrees(theta):.4f} 度")
    print(f"    投放点坐标: ({p_drop[0]:.2f}, {p_drop[1]:.2f}, {p_drop[2]:.2f})")
    print(f"    起爆点坐标: ({p_explode[0]:.2f}, {p_explode[1]:.2f}, {p_explode[2]:.2f})")
    print(f"  最终高精度有效遮蔽时长: {total_occluded_time:.4f} 秒")
    print("="*50)
    return total_occluded_time

# --- 主程序 ---
if __name__ == "__main__":
    start_total_time = time.time()
    
    # 执行第一步
    initial_solution = step1_find_optimal_window()
    
    # 执行第二步
    optimized_solution = step2_local_optimization(initial_solution)
    
    # 执行第三步
    final_result = step3_final_validation(optimized_solution)
    
    end_total_time = time.time()
    print(f"\n程序总耗时: {end_total_time - start_total_time:.2f} 秒")
``````








好的，这个要求非常合理，它将我们的“逆向反推”模型从一个固定的策略（始终选择中点）升级为一个更具探索性的优化过程。通过搜索理想起爆点在导弹-目标视线上的位置，模型可以自主发现到底是“近端遮蔽”（烟幕靠近导弹）还是“远端遮蔽”（烟幕靠近目标）策略更优。

我们将在第一步“全局粗搜索”中加入这个新的搜索维度。

### **第二问建模方案（升级版）：四维粗搜索 + 局部精调**

整体的三步框架保持不变，但第一步的核心逻辑会得到增强。

**第一步：全局粗搜索——最优拦截时空区域定位**

1.  **离散化搜索空间（扩展）：**
    *   **导弹飞行时间 `t_explode`:** 依旧离散化为一系列可能的烟幕起爆时间点。
    *   **烟幕弹飞行时间 `t_delay`:** 依旧离散化为一系列可能的延迟引爆时间。
    *   **（新增）视线遮蔽比例 `los_ratio`:** 这是一个介于0和1之间的参数，定义了理想起爆点在线段上的位置。`P_explode = P_missile + los_ratio * (P_target - P_missile)`。
        *   `los_ratio` 接近0，意味着烟幕在靠近导弹的地方爆炸。
        *   `los_ratio` 接近1，意味着烟幕在靠近目标的地方爆炸。
        *   我们将这个比例也进行离散化搜索（例如从0.1到0.9，步长0.1）。

2.  **逆向可行性检验：**
    *   对于每一个 `(t_explode, t_delay, los_ratio)` 的组合，我们计算出对应的理想起爆点 `P_explode`。
    *   和之前一样，根据 `P_explode` 和 `t_explode`，反向推算出无人机必须满足的投放条件（投放点 `P_drop` 和投放时间 `t_drop`）。
    *   检验推算出的无人机所需飞行速度是否在 ** m/s** 的可行区间内。

3.  **评估与筛选：**
    *   对所有可行的方案，使用**简化模型（真目标中心点）**快速计算其遮蔽时长。
    *   在所有这些方案中，找到那个遮蔽时间最长的组合，将其对应的无人机策略 `(v, θ, t_drop, t_delay)` 和 `los_ratio` 作为“最优初始解”。

**第二、三步保持不变：**
*   **第二步：** 使用坐标上升法，对第一步找到的 `(v, θ, t_drop, t_delay)` 进行高精度、小步长的局部寻优。
*   **第三步：** 将最终优化后的策略，代入高精度（1000个采样点）模型中进行最终验证，得出最终答案。

---

### **Python 代码实现（升级版）**

以下是修改后的代码。主要变动在 `step1_find_optimal_window` 函数中，增加了对 `los_ratio` 的循环搜索。

```python
import numpy as np
import time

# --- 0. 基础设置与物理常量 ---
GRAVITY = 9.8
SMOKE_DURATION = 20.0
SMOKE_RADIUS = 10.0

# 初始位置
uav_initial_pos = np.array([17800, 0, 1800], dtype=float)
missile_initial_pos = np.array([20000, 0, 2000], dtype=float)
false_target_pos = np.array([0, 0, 0], dtype=float)
true_target_base_center = np.array([0, 200, 0], dtype=float)
true_target_height = 10
# 简化模型的目标点 (步骤1和2使用)
simple_target_point = true_target_base_center + np.array([0, 0, true_target_height / 2])

# 导弹轨迹计算
missile_velocity_vector = (false_target_pos - missile_initial_pos) / np.linalg.norm(false_target_pos - missile_initial_pos) * 300.0
missile_total_time = np.linalg.norm(false_target_pos - missile_initial_pos) / 300.0

# --- 步骤1 搜索参数 ---
# 通过调整这里的参数可以改变第一步粗搜索的范围和精度
SEARCH_EXPLODE_TIMES_RANGE = (missile_total_time * 0.4, missile_total_time * 0.9)
SEARCH_EXPLODE_TIMES_STEPS = 20
SEARCH_DELAYS_RANGE = (2.0, 8.0)
SEARCH_DELAYS_STEPS = 15
# !!! 新增的搜索维度 !!!
SEARCH_LOS_RATIO_RANGE = (0.1, 0.9) # 0.1=靠近导弹, 0.9=靠近目标
SEARCH_LOS_RATIO_STEPS = 9          # 从0.1到0.9，步长0.1

# --- 辅助函数 (与之前版本相同) ---
def is_line_segment_intersecting_sphere(p1, p2, sphere_center, sphere_radius):
    if np.any(np.isnan(sphere_center)): return False
    line_vec, point_vec = p2 - p1, sphere_center - p1
    line_len_sq = np.dot(line_vec, line_vec)
    if line_len_sq == 0.0: return np.linalg.norm(point_vec) <= sphere_radius
    t = np.dot(point_vec, line_vec) / line_len_sq
    closest_point = p1 + np.clip(t, 0, 1) * line_vec
    return np.linalg.norm(sphere_center - closest_point) <= sphere_radius

def calculate_simple_occlusion_time(uav_vel, uav_dir_rad, t_drop, t_delay):
    uav_velocity = np.array([np.cos(uav_dir_rad) * uav_vel, np.sin(uav_dir_rad) * uav_vel, 0])
    t_explode = t_drop + t_delay
    p_drop = uav_initial_pos + uav_velocity * t_drop
    v_drop = uav_velocity
    p_explode = p_drop + v_drop * t_delay + np.array([0, 0, -0.5 * GRAVITY * t_delay**2])

    occluded_time = 0
    time_step = 0.1
    for t in np.arange(t_explode, t_explode + SMOKE_DURATION, time_step):
        missile_pos = missile_initial_pos + missile_velocity_vector * t
        smoke_pos = p_explode + np.array([0, 0, -3.0 * (t - t_explode)])
        if is_line_segment_intersecting_sphere(missile_pos, simple_target_point, smoke_pos, SMOKE_RADIUS):
            occluded_time += time_step
    return occluded_time

# --- 步骤 1: 全局粗搜索 (升级版) ---
def step1_find_optimal_window():
    print("--- [步骤 1] 开始：全局粗搜索以寻找最优拦截窗口 ---")
    best_params = {}
    max_occlusion_time = -1
    
    # 离散化搜索空间
    search_explode_times = np.linspace(SEARCH_EXPLODE_TIMES_RANGE[0], SEARCH_EXPLODE_TIMES_RANGE[1], SEARCH_EXPLODE_TIMES_STEPS)
    search_delays = np.linspace(SEARCH_DELAYS_RANGE[0], SEARCH_DELAYS_RANGE[1], SEARCH_DELAYS_STEPS)
    search_los_ratios = np.linspace(SEARCH_LOS_RATIO_RANGE[0], SEARCH_LOS_RATIO_RANGE[1], SEARCH_LOS_RATIO_STEPS)
    
    total_iterations = len(search_explode_times) * len(search_delays) * len(search_los_ratios)
    print(f"粗搜索总迭代次数: {total_iterations}")

    for t_explode in search_explode_times:
        missile_pos_at_explode = missile_initial_pos + missile_velocity_vector * t_explode
        los_vector = simple_target_point - missile_pos_at_explode
            
        for t_delay in search_delays:
            if t_explode <= t_delay: continue
            
            # --- 新增的内层循环 ---
            for los_ratio in search_los_ratios:
                # 1. 确定理想起爆点
                ideal_explode_pos = missile_pos_at_explode + los_ratio * los_vector

                # 2. 反推无人机需求
                t_drop = t_explode - t_delay
                required_uav_velocity_3d = (ideal_explode_pos - uav_initial_pos - np.array([0, 0, -0.5 * GRAVITY * t_delay**2])) / t_explode
                
                # 无人机是等高飞行的，修正垂直速度分量
                required_uav_velocity_3d[2] = 0

                # 3. 检验无人机能力
                required_speed = np.linalg.norm(required_uav_velocity_3d)
                if 70 <= required_speed <= 140:
                    # 方案可行，评估其效果
                    uav_dir_rad = np.arctan2(required_uav_velocity_3d[1], required_uav_velocity_3d[0])
                    current_occlusion_time = calculate_simple_occlusion_time(required_speed, uav_dir_rad, t_drop, t_delay)
                    
                    if current_occlusion_time > max_occlusion_time:
                        max_occlusion_time = current_occlusion_time
                        best_params = {
                            'v': required_speed,
                            'theta_rad': uav_dir_rad,
                            't_drop': t_drop,
                            't_delay': t_delay,
                            'los_ratio': los_ratio, # 记录最优的视线比例
                            'occlusion_time': max_occlusion_time
                        }
    
    print(f"步骤1完成。找到的最佳初始解：")
    print(f"  速度: {best_params['v']:.2f} m/s, 方向: {np.degrees(best_params['theta_rad']):.2f} 度")
    print(f"  投放时间: {best_params['t_drop']:.2f} s, 延迟引爆: {best_params['t_delay']:.2f} s")
    print(f"  最优视线比例: {best_params['los_ratio']:.2f}")
    print(f"  预估遮蔽时长 (简化模型): {best_params['occlusion_time']:.2f} s")
    return best_params

# --- 步骤 2: 局部精搜索 (与之前版本相同) ---
def step2_local_optimization(initial_params):
    print("\n--- [步骤 2] 开始：使用坐标上升法进行局部精细搜索 ---")
    
    params = initial_params.copy()
    
    for i in range(5):
        print(f"迭代轮次 {i+1}/5...")
        last_occlusion_time = params['occlusion_time']
        
        # 优化 v, theta, t_drop, t_delay
        for v_test in np.linspace(max(70, params['v']-5), min(140, params['v']+5), 11):
            t = calculate_simple_occlusion_time(v_test, params['theta_rad'], params['t_drop'], params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['v'] = t, v_test
        for theta_test in np.linspace(params['theta_rad']-np.radians(10), params['theta_rad']+np.radians(10), 11):
            t = calculate_simple_occlusion_time(params['v'], theta_test, params['t_drop'], params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['theta_rad'] = t, theta_test
        for t_drop_test in np.linspace(max(0.1, params['t_drop']-1), params['t_drop']+1, 11):
            t = calculate_simple_occlusion_time(params['v'], params['theta_rad'], t_drop_test, params['t_delay'])
            if t > params['occlusion_time']: params['occlusion_time'], params['t_drop'] = t, t_drop_test
        for t_delay_test in np.linspace(max(0.1, params['t_delay']-1), params['t_delay']+1, 11):
            t = calculate_simple_occlusion_time(params['v'], params['theta_rad'], params['t_drop'], t_delay_test)
            if t > params['occlusion_time']: params['occlusion_time'], params['t_delay'] = t, t_delay_test

        if params['occlusion_time'] - last_occlusion_time < 0.01:
            print("遮蔽时长提升小于0.01s，算法收敛。")
            break
            
    print(f"步骤2完成。优化后的解：")
    print(f"  速度: {params['v']:.4f} m/s, 方向: {np.degrees(params['theta_rad']):.4f} 度")
    print(f"  投放时间: {params['t_drop']:.4f} s, 延迟引爆: {params['t_delay']:.4f} s")
    print(f"  预估遮蔽时长 (简化模型): {params['occlusion_time']:.4f} s")
    return params

# --- 步骤 3: 最终精度验证 (与之前版本相同) ---
def step3_final_validation(final_params, n_points=1000):
    print(f"\n--- [步骤 3] 开始：使用{n_points}个目标点进行最终精度验证 ---")
    
    # 生成目标表面采样点
    points = []
    # (此处省略了生成点的代码，与上一版完全相同)
    for _ in range(int(n_points * 0.6)):
        theta, z = 2 * np.pi * np.random.rand(), true_target_height * np.random.rand()
        points.append([true_target_base_center[0] + 7 * np.cos(theta), true_target_base_center[1] + 7 * np.sin(theta), z])
    for _ in range(int(n_points * 0.4)):
        r, theta = 7 * np.sqrt(np.random.rand()), 2 * np.pi * np.random.rand()
        z = 0 if np.random.rand() < 0.5 else true_target_height
        points.append([true_target_base_center[0] + r * np.cos(theta), true_target_base_center[1] + r * np.sin(theta), z])
    target_points = np.array(points)

    v, theta, t_drop, t_delay = final_params['v'], final_params['theta_rad'], final_params['t_drop'], final_params['t_delay']
    uav_velocity = np.array([np.cos(theta) * v, np.sin(theta) * v, 0])
    t_explode = t_drop + t_delay
    p_drop = uav_initial_pos + uav_velocity * t_drop
    v_drop = uav_velocity
    p_explode = p_drop + v_drop * t_delay + np.array([0, 0, -0.5 * GRAVITY * t_delay**2])

    total_occluded_time = 0
    time_step = 0.01
    for t in np.arange(t_explode, t_explode + SMOKE_DURATION, time_step):
        missile_pos = missile_initial_pos + missile_velocity_vector * t
        smoke_pos = p_explode + np.array([0, 0, -3.0 * (t - t_explode)])
        is_occluded_this_step = any(is_line_segment_intersecting_sphere(missile_pos, tp, smoke_pos, SMOKE_RADIUS) for tp in target_points)
        if is_occluded_this_step: total_occluded_time += time_step
            
    print("\n" + "="*50)
    print("  第二问最优策略及最终结果")
    print("="*50)
    print("  最优策略参数:")
    print(f"    无人机飞行速度: {v:.4f} m/s")
    print(f"    无人机飞行方向: {np.degrees(theta):.4f} 度")
    print(f"    投放点坐标: ({p_drop[0]:.2f}, {p_drop[1]:.2f}, {p_drop[2]:.2f})")
    print(f"    起爆点坐标: ({p_explode[0]:.2f}, {p_explode[1]:.2f}, {p_explode[2]:.2f})")
    print(f"  最终高精度有效遮蔽时长: {total_occluded_time:.4f} 秒")
    print("="*50)
    return total_occluded_time

# --- 主程序 ---
if __name__ == "__main__":
    start_total_time = time.time()
    initial_solution = step1_find_optimal_window()
    if not initial_solution:
        print("错误：第一步未能找到任何可行的初始解，请检查搜索范围或约束条件。")
    else:
        optimized_solution = step2_local_optimization(initial_solution)
        final_result = step3_final_validation(optimized_solution)
    end_total_time = time.time()
    print(f"\n程序总耗时: {end_total_time - start_total_time:.2f} 秒")```

### **如何使用和解读**

1.  **调整搜索参数：** 在代码的 `--- 步骤1 搜索参数 ---` 部分，你可以自由调整五个参数来控制第一步粗搜索的范围和粒度。
    *   `SEARCH_LOS_RATIO_RANGE` 和 `SEARCH_LOS_RATIO_STEPS` 是这次新增的关键。
2.  **运行程序：** 直接执行代码即可。
3.  **观察第一步的结果：** 在第一步的输出中，新增了一行“最优视线比例”。这个值会告诉你，模型发现的最佳策略是让烟幕靠近导弹（值接近0.1）还是靠近目标（值接近0.9），或是介于中间。这是一个非常有价值的洞察。
4.  **最终结果：** 程序的最终输出格式和之前一样，给出了最优的无人机飞控参数和最终的高精度遮蔽时长。

这个升级后的版本，通过将一个硬编码的策略（中点）参数化，并将其纳入优化过程，使得模型更加智能和强大，更有可能找到全局最优解。